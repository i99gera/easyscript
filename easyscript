#!/usr/bin/env /usr/bin/python3
def prrint(*a,**s):
 print(*a,**s)
###############################
#prrint('\x1b[93m[compiling \x1b[93;5m...\x1b]\x1b[0m',end='\r')
from sys import argv
from os import system as sh
from os import popen as pp
from os.path import exists
from random import randint
from binascii import hexlify
from binascii import unhexlify
msym=65536
mod=[]
uns=[]
fif=[]
com=[]
asym='qazwsxedcrfvtgbyhnujmikolp_QAZWSXEDCRFVTGBYHNUJMIKOLP0192837465'
quo=0
struct=dict()
maint=['str','int','float','char','double','bool','void','file','auto']
unpac={'c':'const','u':'unsigned','l':'long','s':'static','e':'extern','g':'one_string_global'}
io={
 'int':'i',
 'lint':'li',
 'llint':'Li',
 'float':'f',
 'double':'lf',
 'ldouble':'Lf',
 'char':'c',
 'str':'s',
 'uint':'u',
 'luint':'lu',
 'lluint':'Lu',
}
struop=''
struos=0
debug=dict()
casebr=1
argv =argv[1:]
listvars=[dict()]
hm='''
usage:
compiles to .cpp then to binary and then run the file
compiles always to outcode.cpp then to a.out
./easyscript [args] file
args can be:
-c	compile to .cpp and exit
-r	decompile .cpp file
-u	create readable .cpp file, cannot be decompiled
-d	makes .cpp code dirty and unreadable, can be used for creating encrypted code
-b	in case of error displays only first 256 symbols of error msg
args cannot be joined, for example use -b -c instead of -bc
running without args will compile and run
'''
###############################
unhack=1
if '-d' in argv:
 unhack=0
 argv=[w for w in argv if w != '-d']
###############################
if '-h' in argv:
 argv=[w for w in argv if w != '-h']
 print(hm)
 exit()
###############################
if '-help' in argv:
 argv=[w for w in argv if w != '-help']
 print(hm)
 exit()
###############################
if '--help' in argv:
 argv=[w for w in argv if w != '--help']
 print(hm)
 exit()
###############################
if '-gcc' in argv:
 argv=[w for w in argv if w not in '-gcc']
 q=pp('gcc --version').read()
 q=q.split()
 if len(q) > 2:
  q=q[2]
 else:
  q=q[0]
 q=q.split('.')[0]
 q=int(q)
 if q<10:
  for w in io.keys():
   if 'L' in io[w]:
    io[w]=io[w].replace('L','ll')
###############################
uncom=1
if '-u' in argv:
 argv=[w for w in argv if w!='-u']
 uncom=0
###############################
brief=0
if '-b' in argv:
 argv=[w for w in argv if w!='-b']
 brief=1
###############################
brtg=0
if '-brtg' in argv:
 argv=[w for w in argv if w!='-brtg']
 brtg=1
###############################
node=0
if '-node' in argv:
 argv=[w for w in argv if w!='-node']
 node=1
###############################
unrun=1
if '-c' in argv:
 argv=[w for w in argv if w != '-c']
 unrun=0
###############################
restore=0
if '-r' in argv:
 argv=[w for w in argv if w!= '-restore']
 restore=1
###############################
def itype(q,i=0):
 q=q.strip()
 if q=='':
  return ''
 if q[0]=='*':
  q=q[1:]
 while q[0]=='(':
  q=q[1:]
 e=q
 e=e.split('[')[0]
 e=e.split('(')[0]
 e=e.strip()
 e=e.split('+')[0]
 e=e.split('-')[0]
 e=e.split('*')[0]
 q=e.split('/')[0]
 if '.' in q:
  q=q.split('.')
  q=[w.strip() for w in q]
  return struct[itype(q[0])][q[1]]
 if q[-2:]=='LL' and (q[:-2].isdigit() or q[0]=='-' and q[1:-2].isdigit()):
  return 'llint'
 if q[-1:]=='L' and (q[:-1].isdigit() or q[0]=='-' and q[1:-1].isdigit()):
  q=int(q[:-1])
  if -2**63<=q<2**63:
   return 'lint'
  else:
   return 'llint'
 if q.isdigit() or q[:1]=='-' and q[1:].isdigit():
  q=int(q)
  if -2**31<=q<2**31:
   return 'int'
  elif -2**63<=q<2**63:
   return 'lint'
  else:
   return 'llint'
 e=''
 global listvars
 for w in listvars:
  if q in w:
   e=w[q]
 '''
 global vars
 global defnow
 for w in defnow:
  if '*'+q in vars[w[1]].keys():
   e=vars[w[1]]['*'+q]
  if q in vars[w[1]].keys():
   e=vars[w[1]][q]
 e=e.replace('*','')
'''
 e=typesplit(e)
 if i:
  e[0]=''.join([w for w in e[0] if w not in 'c'])
 e=e[0]+e[1]
 return e
###############################
def typesplit(q):
 q=''.join([w for w in q if w in asym])
 if q in struct:
  return ['',q]
 be=''
 en=''
 for w in maint:
  if q[-len(w):] == w:
   en=w
   be=q[:-len(w)]
   break
 if 'l' in be and en == 'float':
  be=be[:be.index('l')]+be[be.index('l')+1:]
  en='double'
 be=''.join(sorted(be))
 return [be,en]
###############################
def unp(q,ww=0):
 global mod
 a=typesplit(q)
 be,en=a
 if ww in [2,3]:
  if be+en:
   if ww == 2:
    return ''.join(sorted(be))+en
   if ww == 3:
    return [''.join(sorted(be)),en]
  else:
   return q
 if en == 'file':
  en='FILE'
  mod+=['stdlib.h']
 if en == 'str':
  en='char'
  mod+=['string.h']
 if ww:
  if be+en:
   return 1
  else:
   return 0
 if be+en:
  toex=''
  for w in unpac.keys():
   toex+=(unpac[w]+' ')*be.count(w)
  return toex+en
 return q
###############################
def gio(q):
 q=unp(q,3)
 q[0]=[w for w in q[0] if w in 'lLu']
 q[0]=sorted(q[0])
 if q[1]=='bool':
  q[1]='int'
 q[0]=''.join(q[0])
 if q[1]=='auto':
  print('\x1b[91m[error]\x1b[0m unable to print type auto')
  exit()
 return io[q[0]+q[1]]
###############################
def init(q,fun=None):
 q=q.strip()
 q=' '.join(q.split())
 type=q.split()[0]
 q=' '.join(q.split()[1:]).strip()
 name=q.split('[')[0].split('(')[0].strip()
 global listvars
 listvars[-1][name]=type
 return [type,name]
###############################
if not (argv):
 print('and what file should I compile? run with -h for help')
 exit(1)
###############################
if not(exists(argv[0])):
 prrint('\x1b[91m[error]\x1b[0m Could not find '+argv[0])
 exit(2)
###############################
a=open(argv[0])
q=a.read()
a.close()
ort=q
##############################
if restore:
 a=open('restore','w')
 q=q.split('\n')[0]
 q=[w for w in q if w in '0123456789abcdef']
 q=''.join(q)
 print(q)
 a.write(unhexlify(q.encode()).decode())
 a.close()
 exit()
##############################
q+='\npass\n'
##############################
'''
q=q.split('\n')
for w in range(len(q)):
 if '#' in q[w]:
  q[w]=q[w].replace('#','/*')+'*/'
q='\n'.join(q)
##############################
q=q.replace("",chr(msym+1))#
quo=0
nq=''
for w in q:
 if w == chr(msym+1):
  quo=1-quo
 if quo and w=='\n':
  nq+='\\n'
 else:
  nq+=w
q=nq.replace(chr(msym+1),'"')
###############################
nq=''
bs=0
for w in q:
 if w == '"' and quo in [1,0] and bs==0:
  quo=1-quo
  nq+=w
  continue
 if w == "'" and quo in [2,0] and bs==0:
  quo=2-quo
  nq+=w
  continue
 if quo:
  nq+=chr(msym+ord(w))
 else:
  nq+=w
 bs=0
 if w=='\\':
  bs=1
q=nq
###############################
q=''.join([chr(ord(w)%msym) for w in q])
q=q.replace('/*',chr(msym+1))
q=q.replace('*/',chr(msym+2))
com=1
nq=''
for w in q:
 if w==chr(msym+1):
  com=0
 if com:
  nq+=w
 if w==chr(msym+2):
  com=1
q=nq
'''
###############################
q=''.join([chr(ord(w)%msym) for w in q])
nq=''
ws=0
while q:
 if ws==0 and q[:3]=="'''":#'''
  ws=1
  nq+='"'
  q=q[3:]
 elif ws==1 and q[:3]=="'''":#'''
  ws=0
  nq+='"'
  q=q[3:]
 elif ws==0 and q[:1]=='"':
  ws=2
  nq+='"'
  q=q[1:]
 elif ws==2 and q[:1]=='"':
  ws=0
  nq+='"'
  q=q[1:]
 elif ws==0 and q[:1]=="'":
  ws=3
  nq+="'"
  q=q[1:]
 elif ws==3 and q[:1]=="'":
  ws=0
  nq+="'"
  q=q[1:]
 elif ws==0 and q[:2]=='%*':
  ws=4
  q=q[2:]
 elif ws==4 and q[:2]=='*%':
  ws=0
  q=q[2:]
 elif ws==0 and q[:2]=='/*':
  ws=5
  q=q[2:]
 elif ws==5 and q[:2]=='*/':
  ws=0
  q=q[2:]
 elif ws==0 and q[:1]=='#':
  ws=6
  q=q[1:]
 elif ws==6 and q[:1]=='\n':
  ws=0
  q=q[1:]
 elif ws==0:
  nq+=q[0]
  q=q[1:]
 elif ws==1:
  add=q[0]
  q=q[1:]
  if add=='\n':
   if brtg:
    add='<br>'
   else:
    add='\\n'
  if add=='\'':
   add='\\\''
  if add=='\"':
   add='\\\"'
  nq+=add
 elif ws<5:
  nq+=chr(msym+ord(q[0]))
  q=q[1:]
 else:
  q=q[1:]
q=nq
###############################
q=q.replace(';','\n')
###############################
q=q.replace('\t',' ')
###############################
q=q.split('\n')
###############################
q=[w for w in q if w != ' '*len(w)]
q=[[0,w,''] for w in q]
for w in q:
 while w[1][0] == ' ':
  w[1]=w[1][1:]
  w[0]+=1
 while w[1][-1] == ' ':
  w[1]=w[1][:-1]
###############################
for w in q:
 nodc=':;'+chr(msym+ord('\n'))
 if node:
  nodc+='>'
 if w[1][-1] not in nodc and w[1].split(' ')[0] not in ['import']:
   w[1]+=';'
###############################
deb=-1
for w in q:
 if w[1][:5]=='debug' and w[1][-1]==':':
  deb=w[0]
  w[1]='global:'
 elif w[0]<=deb:
  deb=-1
 elif deb>-1:
  wd=w[1].split('=')
  debug[wd[0]]=wd[1]
  w[1]='int debug_'+w[1]
###############################
if node==0:
 main=[]
 inmain=1
 for w in q:
  if w[0] == 0:
   inmain=1
  if w[1][:4] == 'def ':
   inmain=0
  if w[1][:6] == 'global' and w[1][-1] == ':':
   inmain=2
   w[1]=''
  if inmain==1:
   main+=[w[:]]
   w[1]=''
  if inmain==2:
   w[0]-=1
 q=[w for w in q if w[1] != '']
 q+=[[0,'def int main():','']]
 for w in main:
  w[0]+=1
 q+=main
###############################
#start#
###############################
linow=-1
switch=[]
defnow=[[-1,'global']]
for w in q:
 listvars=listvars[:w[0]+1]
 while len(listvars)<w[0]+1:
  listvars+=[dict()]
 linow+=1
 if switch and w[0] <= switch[-1][0]:
  switch=switch[:-1]
 if w[0] <= struos:
  struop=''
 while w[0] <= defnow[-1][0]:
  defnow=defnow[:-1]
 if switch and switch[-1][1] == -1 and w[1][-1]==':':
  switch[-1][1]=w[0]
  w1=w[1][:-1]
  w[1]=''
  for w2 in w1.split(','):
   w[1]+='case '+w2+':'
 elif switch and switch[-1][1]==w[0] and w[1][:7]=='default'and w[1][-1]==':':
  w[1]=('break;\n'+' '*w[0])*casebr+w[1]
  casebr=1
 elif switch and switch[-1][1]==w[0] and w[1][-1]==':':
  w1=w[1][:-1]
  w[1]=('break;\n'+' '*w[0])*casebr
  for w2 in w1.split(','):
   w[1]+='case '+w2+':'
  casebr=1
 elif w[1][:7]=='switch ' and w[1][-1]==':':
  w[1]='switch('+w[1][7:-1]+')'
  switch+=[[w[0],-1]]
 elif w[1]=='unbreak;':
  casebr=0
  w[1]=''
 elif w[1][:5]=='each ' and w[1][-1]==':':
  tmpar=w[1][5:-1].strip()
  tmpit='each_'+tmpar
  w[1]=''
  if itype('index_'+tmpit)=='':
   init('int index_'+tmpit)
   w[1]+='int index_'+tmpit+';\n'+' '*w[0]
  if itype('tmpit')=='':
   init(itype(tmpar)+' '+tmpit)
   w[1]+=unp(itype(tmpar))+' '+tmpit+';\n'+' '*w[0]
  w[1]+='for(index_'+tmpit+'=0,'+tmpit+'='+tmpar+'[index_'+tmpit+'];index_'+tmpit+'<len_'+tmpar+';'+tmpar+'[index_'+tmpit+']='+tmpit+',index_'+tmpit+'++)'
  w[2]+=tmpit+'='+tmpar+'[index_'+tmpit+'];'
 elif w[1][:7] == 'import ':
  mod+=[w[1][7:]]
  w[1]=''
 elif [e for e in w[1] if e != ' '] == list('aimport;'):
  mod+=['bits/stdc++']
  w[1]=''
 elif w[1][:8] == 'cimport ':
  mod+=[w[1][8:-1]+'.h']
  w[1]=''
 elif w[1][:8] == 'limport ':
  fif+=[w[1][8:-1].strip()]
  w[1]=''
 elif [e for e in w[1] if e!=' '][:3] == list('sh('):
  mod+=['stdlib.h']
  w[1]='system'+w[1][2:]
 elif w[1][:4] == 'for ' and w[1][-1] == ':':
  w[1]=w[1][4:-1].strip()
  if w[1].count(':')==2:
   w[1]='for('+w[1].replace(':',';').replace(' and ',' && ').replace(' or ',' || ').replace(' not ',' ! ')+')'
  elif ' in ' in w[1]:
   tmpit=w[1].split(' in ')[0].strip()
   tmpar=w[1].split(' in ')[1].strip()
   listvars+=[dict()]
   init(itype(tmpar)+' '+tmpit)
   w[1]='for('+itype(tmpar)+' '+tmpit+':'+tmpar+')'
   '''
   w[1]=''
   if itype('index_'+tmpit)=='':
    init('int index_'+tmpit)
    w[1]+='int index_'+tmpit+';\n'+' '*w[0]
   if itype(tmpit)!=itype(tmpar):
    init(itype(tmpar)+' '+tmpit)
    w[1]+=itype(tmpar)+' '+tmpit+';\n'+' '*w[0]
   w[1]+='for(index_'+tmpit+'=0,'+tmpit+'='+tmpar+'[index_'+tmpit+'];index_'+tmpit+'<len_'+tmpar+';'+tmpar+'[index_'+tmpit+']='+tmpit+',index_'+tmpit+'++,'+tmpit+'='+tmpar+'[index_'+tmpit+'<len_'+tmpar+'-1?index_'+tmpit+':len_'+tmpar+'-1])'
   '''
  else:
   test=':'.join(w[1].split(':')[1:]).replace(' and ',' && ').replace(' or ',' || ').replace(' not ',' ! ')
   w[1]=w[1].split(':')[0]
   te=0
   if '<' in w[1] or '>' in w[1]:
    while w[1][te] not in '<>':
     te+=1
    te=w[1][te]
   if te=='<':
    if '=' not in w[1]:
     w[1]='0='+w[1]
    beg=w[1].split('=')[0]
    it=w[1].split('=')[1].split('<')[0]
    end=w[1].split('<')[1]
    st='++'
   if te=='>':
    if '=' not in w[1]:
     w[1]='0='+w[1]
    beg=w[1].split('=')[0]
    it=w[1].split('=')[1].split('>')[0]
    end=w[1].split('>')[1]
    st='--'
   if test:
    w[1]='for('+it+'='+beg+';'+test+';'+it+st+')'
   else:
    w[1]='for('+it+'='+beg+';'+it+te+end+';'+it+st+')'
   '''
   ext='for('
   if '<' in w[1]:
    if '=' in w[1]:
     ext+=w[1].split('=')[1].split('<')[0]
     ext+='='
     ext+=w[1].split('<')[0].split('=')[0]
     ext+=';'
     if test:
      ext+=test
     else:
      ext+=w[1].split('=')[1]
     ext+=';'
     ext+=w[1].split('=')[1].split('<')[0]
     ext+='++)'
    else:
     ext+=w[1].split('<')[0]
     ext+='=0;'
     if test:
      ext+=test
     else:
      ext+=w[1]
     ext+=';'
     ext+=w[1].split('<')[0]
     ext+='++)'
   if '>' in w[1]:
    if '=' in w[1]:
     ext+=w[1].split('=')[1].split('>')[0]
     ext+='='
     ext+=w[1].split('>')[0].split('=')[0]
     ext+=';'
     if test:
      ext+=test
     else:
      ext+=w[1].split('=')[1]
     ext+=';'
     ext+=w[1].split('=')[1].split('>')[0]
     ext+='--)'
    else:
     ext+=w[1].split('>')[0]
     ext+='=0;'
     if test:
      ext+=test
     else:
      ext+=w[1]
     ext+=';'
     ext+=w[1].split('>')[0]
     ext+='--)'
    '''

   if itype(it)!=itype(end,1) and itype(end,1):
    init(itype(end,1)+' '+it)
    w[1]=unp(itype(end,1))+' '+it+';\n'+' '*w[0]+w[1]
   #w[1]=ext
 elif w[1][:6] == 'while ' and w[1][-1] == ':':
  w[1]='while('+w[1][6:-1].replace(' and ',' && ').replace(' or ',' || ').replace(' not ',' ! ')+')'
 elif w[1][:6] == 'while ' and w[1][-1] == ';':
  w[1]='while('+w[1][6:-1].replace(' and ',' && ').replace(' or ',' || ').replace(' not ',' ! ')+');'
 elif w[1][:4] == 'for ' and w[1][-1] != ':':
  w[1]='for('+w[1][4:-1].replace(' and ',' && ').replace(' or ',' || ').replace(' not ',' ! ')+')'
 elif w[1] == 'pass;':
  w[1]=''
 elif w[1][:5] == 'elif ' and w[1][-1] == ':':
  w[1]='else if('+w[1][5:-1].replace(' and ',' && ').replace(' or ',' || ').replace(' not ',' ! ')+')'
 elif [e for e in w[1] if e!=' '] == list('else:'):
  w[1]='else'
 elif [e for e in w[1] if e!=' '] == list('do:'):
  w[1]='do'
 elif w[1][:7] == 'resize ':
  mod+=['stdlib.h']
  w[1]=w[1][7:-1]
  vat=w[1]
  tmpvar='['.join(vat.split('[')[:-1])
  tmptype=itype(tmpvar)
  tmpcount=vat.split('[')[-1].split(']')[0]
  tmpouttype=unp(tmptype)
  w[1]=tmpvar+'=('+tmpouttype+'*)realloc('+tmpvar+',sizeof('+tmpouttype+')*('+tmpcount+'));len_'+tmpvar.strip()+'='+tmpcount+';'
 elif w[1][:4] == 'mal ':
  mod+=['stdlib.h']
  w[1]=w[1][4:-1]
  vat=w[1]
  tmpvar='['.join(vat.split('[')[:-1])
  tmptype=itype(tmpvar)
  tmpcount=vat.split('[')[-1].split(']')[0]
  tmpouttype=unp(tmptype)
  w[1]='len_'+tmpvar.strip()+'='+tmpcount+';'+tmpvar+'=('+tmpouttype+'*)malloc(sizeof('+tmpouttype+')*(len_'+tmpvar.strip()+'));'
 elif w[1][:4] == 'cal ':
  mod+=['stdlib.h']
  w[1]=w[1][4:-1]
  vat=w[1]
  tmpvar='['.join(vat.split('[')[:-1])
  tmptype=itype(tmpvar)
  tmpcount=vat.split('[')[-1].split(']')[0]
  tmpouttype=unp(tmptype)
  w[1]='len_'+tmpvar.strip()+'='+tmpcount+';'+tmpvar+'=('+tmpouttype+'*)calloc((len_'+tmpvar.strip()+'),sizeof('+tmpouttype+'));'
 elif w[1][:4] == 'add ':
  mod+=['stdlib.h']
  w[1]=w[1][4:-1]
  vat=w[1]
  tmpvar='['.join(vat.split('[')[:-1])
  tmptype=itype(tmpvar)
  tmpcount=vat.split('[')[-1].split(']')[0]
  tmpouttype=unp(tmptype)
  w[1]=tmpvar+'=('+tmpouttype+'*)realloc('+tmpvar+',sizeof('+tmpouttype+')*(len_'+tmpvar.strip()+'+1));len_'+tmpvar.strip()+'++;'+tmpvar+'[len_'+tmpvar.strip()+'-1]='+tmpcount+';'
 elif w[1][:5] == 'cnew ':
  mod+=['stdlib.h']
  w[1]=w[1][:-1]
  tmptype=w[1].split()[1]
  tmpouttype=unp(tmptype)
  vat=' '.join(w[1].split()[2:])
  tmpvar=vat.split('[')[0]
  tmpcount=vat.split('[')[1].split(']')[0]
  init(tmptype+' '+tmpvar)
  init('int len_'+tmpvar.strip())
  w[1]='int len_'+tmpvar.strip()+'='+tmpcount+';'+tmpouttype +'*'+tmpvar+'=('+tmpouttype+'*)calloc((len_'+tmpvar.strip()+'),sizeof('+tmpouttype+'));'
 elif [e for e in w[1]][:5] == list('sort('):
  mod+='algorithm functional array iostream iterator'.split()
  uns+=['std']
 elif w[1][:4]=='new ':
  w[1]=w[1][4:].strip()
  tmptype=w[1].split(' ')[0]
  w[1]=' '.join(w[1].split(' ')[1:])
  init(tmptype+' '+w[1])
  w[1]='vector <'+tmptype+'> '+w[1]
  mod+=['vector']
  uns+=['std']
 elif w[1][:6] =='class ' and w[1][-1]==':':
  struct+=w[1][6:-1].strip()
  w[1]=w[1][:-1]
 elif w[1][:5]=='push ':
  w[1]=w[1][5:-2]
  te=1
  op=1
  while op:
   if w[1][-te]=='[':
    op-=1
   if w[1][-te]==']':
    op+=1
   te+=1
  tmpedd=w[1][:-te+1]
  tmpadd=w[1][-te+2:]
  w[1]=tmpedd+'.push_back('+tmpadd+');'
 elif w[1][:5]=='name ':
  uns+=[w[1][5:].strip()]
  w[1]=''
 elif w[1][:5] == 'mnew ':
  mod+=['stdlib.h']
  w[1]=w[1][:-1]
  tmptype=w[1].split()[1]
  tmpouttype=unp(tmptype)
  vat=' '.join(w[1].split()[2:])
  tmpvar=vat.split('[')[0]
  tmpcount=vat.split('[')[1].split(']')[0]
  init(tmptype+' '+tmpvar)
  init('int len_'+tmpvar.strip())
  w[1]='int len_'+tmpvar.strip()+'='+tmpcount+';'+tmpouttype +'*'+tmpvar+'=('+tmpouttype+'*)malloc(sizeof('+tmpouttype+')*(len_'+tmpvar.strip()+'));'
 elif w[1][:3] == 'if ' and w[1][-1] == ':':
  w[1]='if('+w[1][3:-1].replace(' and ',' && ').replace(' or ',' || ').replace(' not ',' ! ')+')'
 elif w[1][:4]=='scan' and [e for e in w[1] if e!=' '][:5] == list('scan('):
  mod+=['stdio.h']
  tmp1=''
  tmp2=''
  tmp3=''
  w[1]='('.join(w[1].split('(')[1:])
  w[1]=')'.join(w[1].split(')')[:-1])
  file=w[1].split(',')[0] if ',' in w[1] else ''
  if itype(file)=='file':
   w[1]=','.join(w[1].split(',')[1:])
  else:
   file=''
  for e in w[1].split(','):
   if len(e.split())>1 and unp(e.split()[0],1):
    tmp3+=unp(e.split()[0])+' '+' '.join(e.split()[1:])+';\n'+' '*w[0]
    init(e.split()[0]+' '+' '.join(e.split()[1:]))
    tmp1+='%'+gio(e.split()[0])
    tmp2+=','+'&('+' '.join(e.split()[1:])+')'
    continue
   e=e.strip()
   if e[0] == '`':
    add=0
    e=e[1:]
   else:
    add=1
   if e[0]==e[-1] and e[0] in '\"\'':
    tmp1+=e[1:-1]
   elif '`' in e:
    tmp1+='%'+e.split('`')[1].strip()
    tmp2+=','+'&('*add+e.split('`')[0].strip()+')'*add
   else:
    tmptype=e.split('[')[0].strip().replace('*','')
    deffo=itype(tmptype)
    if deffo:
     tmp1+='%'+gio(deffo)
     tmp2+=','+'&('*add+e.strip()+')'*add
    else:
     prrint('\x1b[91m[error line '+str(linow)+']\x1b[0m could not scan '+tmptype+' at '+w[1])
     exit(5)
  if file:
   w[1]=tmp3+'fscanf('+file+',"'+tmp1+'"'+tmp2+');'
  else:
   w[1]=tmp3+'scanf("'+tmp1+'"'+tmp2+');'
 elif w[1][:5]=='print' and [e for e in w[1] if e!=' '][:6] == list('print('):
  mod+=['stdio.h']
  tmp1=[]
  tmp2=''
  sep=' '
  end='\\n'
  w[1]='('.join(w[1].split('(')[1:])
  w[1]=')'.join(w[1].split(')')[:-1])
  file=w[1].split(',')[0]
  if '.' not in file and itype(file)=='file':
   w[1]=','.join(w[1].split(',')[1:])
  else:
   file=''
  for e in w[1].split(','):
   e=e.strip()
   if e=='':
    pass
   elif len(e.split('='))==3 and e.split('=')[0].strip()=='format':
    format,sep,end=e.split('=')
    sep=sep.strip()[1:-1]
    end=end.strip()[1:-1]
   elif e[0] == '"' and e[-1] == '"':
    tmp1+=[e[1:-1]]
   elif e[0] == "'" and e[-1] == "'":
    tmp1+=[e[1:-1]]
   elif '`' in e:
    tmp1+=['%'+e.split('`')[1].strip()]
    tmp2+=','+e.split('`')[0].strip()
   else:
    tmptype=e.split('[')[0].strip().replace('*','')
    deffo=itype(tmptype)
    if deffo:
     tmp1+=['%'+gio(deffo)]
     tmp2+=','+e.strip()
    else:
     prrint('\x1b[91m[error line '+str(linow)+']\x1b[0m could not print '+tmptype+' at '+w[1])
     exit(6)
  if file:
   w[1]='fprintf('+file+',"'+sep.join(tmp1)+end+'"'+tmp2+');'
  else:
   w[1]='printf("'+sep.join(tmp1)+end+'"'+tmp2+');'
  if 'printlimit' in debug:
   w[1]+='debug_printlimit--;if (debug_printlimit < 0) {printf("\033[31m[debug_printlimit]\033[0m\\n");return 0;}'
 elif w[1][:4] == 'def ' and w[1][-1] == ':':
  w[1]=w[1][4:-1]
  if len(w[1].split('(')[0].split())<2:
   if node:
    w[1]='function '+w[1]
   else:
    w[1]='auto '+w[1]
   #prrint('\x1b[91m[error line '+str(linow)+']\x1b[0m unktown type of function: '+w[1])
   #exit()
  defnow+=[[w[0],w[1].split('(')[0].split()[1]]]
  nw=init(w[1].split('(')[0])
  listvars+=[dict()]
  nw=unp(nw[0])+' '+nw[1]+'('
  nwl=[]
  for e in w[1].split('(')[1].split(')')[0].split(','):
   if e != ' '*len(e):
    if ' ' not in e.strip():
     e='auto '+e
    tmp=init(e)
    nwl+=[unp(tmp[0])+' '+tmp[1]]
  w[1]=nw+','.join(nwl)+')'
 elif w[1][:7] == 'struct ' and w[1][-1]==':':
  struop=w[1][7:-1].strip()
  struct[struop]=dict()
  w[1]='typedef '+w[1][:-1]
  struos=w[0]
 elif unp(w[1].split(' ')[0],1):
  tmp=' '.join(w[1][:-1].split(' ')[1:])
  tmptype=w[1].split(' ')[0]
  nw=unp(tmptype)+' '
  for e in tmp.split(','):
   ee=e.split('=')[0]
   if struop:
    struct[struop][ee]=tmptype
   else:
    init(tmptype+' '+ee)
   nw+=e+','
  if tmptype in struct:
   nw=nw
  w[1]=nw[:-1]+';'
 elif node == 0 and '=' in w[1] and set(w[1].split('=')[0].strip()) | set(asym) == set(asym) and itype(w[1].split('=')[0])=='':
  init(itype(w[1][:-1].split('=')[1])+' '+w[1].split('=')[0])
  w[1]=unp(itype(w[1][:-1].split('=')[1]))+' '+w[1]
###############################
q+=[[0,'','']]
struop=-1
for w in range(len(q)-1):
 if (q[w][1][:15]=='typedef struct ' or q[w][1][:6]== 'class ' )and q[w][1][-1]!=';':
  struop=q[w][0]
 if q[w][0] == q[w+1][0]:
  q[w]=' '*unhack*q[w][0]+q[w][1]+('\n'+' '*unhack*q[w][0])*int(bool(len(q[w][2])))+q[w][2]
 elif q[w][0] > q[w+1][0]:
  q[w]=' '*unhack*q[w][0]+q[w][1]+'}'*(q[w][0]-q[w+1][0])+('\n'+' '*unhack*q[w][0])*int(bool(len(q[w][2])))+q[w][2]
 elif q[w][0] < q[w+1][0]:
  q[w]=' '*unhack*q[w][0]+q[w][1]+'{'*(q[w+1][0]-q[w][0])+('\n'+' '*unhack*q[w][0])*int(bool(len(q[w][2])))+q[w][2]
 if q[w+1][0]<=struop:
  q[w]+=';'
  struop=-1
q[-1]=''
###############################
q=('\n').join(q)
###############################
q=q.split('\n')
###############################
w=0
while 'int main()' not in q[w]:
 w+=1
q1=[]
q4=q[:w]
q2=q[w:]
q3=[]
for w in q2:
 if 'one_string_global ' in w:
  w=w.replace('one_string_global ','')
  q1+=[w]
 else:
  q3+=[w]
q=q1+q4+q3
###############################
q=('\n'*unhack).join(q)
###############################
mod=list(set(mod))
mods=''
mmods=''
uns=list(set(uns))
for w in uns:
 mods+='using namespace '+w+';\n'
fif=list(set(fif))
for w in fif:
 if w=='scani':
  mods+='int scani(){int q;scanf("%i",&q);return q;}\n'
  mod+=['stdio.h']
 if w=='rand':
  mmods+='\nsrand(time(NULL));'
  mod+=['stdlib.h','time.h']
rmods=''
mod=list(set(mod))
for w in mod:
 rmods+='#include <'+w+'>\n'
q=rmods+mods+q
q=q.replace('int main(){','int main(){'+mmods)
###############################
q=''.join([chr(ord(w)%msym) for w in q])
###############################
ort=hexlify(ort.encode()).decode()
if node:
 a=open('index.html','w')
 a.write(('<!--'+ort+'-->\n')*uncom+q)
else:
 a=open('outcode.cpp','w')
 a.write(('////'+ort+'\n')*uncom+q)
a.close()
###############################
if unrun:
 if brief:
  qq=sh('(g++ outcode.cpp 2>&1) > out__tmp____')
  qqq=open('out__tmp____').read()
  sh('rm out__tmp____')
  if qq:
   print(qqq[:256])
   exit()
 else:
  if sh('g++ outcode.cpp'):
   exit()
 try:
  q=sh('./a.out')
 except KeyboardInterrupt:
  q=2
 if q:
  prrint()
  prrint('\x1b[93m[exit code: '+str(q)+']\x1b[0m')
 exit(q)
