#!/usr/bin/env /usr/bin/python3
def prrint(*a,**s):
 print(*a,**s)
###############################
#prrint('\x1b[93m[compiling \x1b[93;5m...\x1b]\x1b[0m',end='\r')
from sys import argv
from os import system as sh
from os import popen as pp
from os.path import exists
from random import randint
from random import choice
from binascii import hexlify
from binascii import unhexlify
msym=65536
mod=[]
uns=[]
fif=[]
com=[]
gcomp='g++ {}'
asym='qazwsxedcrfvtgbyhnujmikolp_QAZWSXEDCRFVTGBYHNUJMIKOLP0192837465'
quo=0
struct=dict()
maint=['str','int','float','char','double','bool','void','file','auto','string']
unpac={'h':'short','c':'const','u':'unsigned','l':'long','s':'static','e':'extern','g':'one_string_global'}
io={
 'hint':'h',
 'hhint':'hh',
 'int':'i',
 'lint':'li',
 'llint':'Li',
 'float':'f',
 'lfloat':'lf',
 'llfloat':'Lf',
 'double':'lf',
 'ldouble':'Lf',
 'char':'c',
 'str':'s',
 'string':'s',
 'uint':'u',
 'luint':'lu',
 'lluint':'Lu',
}
struop=''
struos=0
debug=dict()
casebr=1
argv =argv[1:]
listvars=[dict()]
hm='''
usage:
compiles to .cpp then to binary and then run the file
compiles always to outcode.cpp then to a.out
./easyscript [args] file
args can be:
-c	compile to .cpp and exit
-r	decompile .cpp file
-u	create readable .cpp file, cannot be decompiled
-d	makes .cpp code dirty and unreadable, can be used for creating encrypted code, but in case of using without -u file can be decompiled and read
-b	in case of error displays only first 256 symbols of error msg
-e	show exit code
-s	make int smaller
args cannot be joined, for example use -b -c instead of -bc
running without args will compile and run
'''
###############################
exitcode=0
if '-e' in argv:
 exitcode=1
 argv=[w for w in argv if w != '-e']
###############################
smint=0
if '-s' in argv:
 smint=1
 argv=[w for w in argv if w != '-s']
###############################
unhack=1
if '-d' in argv:
 unhack=0
 argv=[w for w in argv if w != '-d']
###############################
if '-h' in argv:
 argv=[w for w in argv if w != '-h']
 print(hm)
 exit()
###############################
if '-help' in argv:
 argv=[w for w in argv if w != '-help']
 print(hm)
 exit()
###############################
if '--help' in argv:
 argv=[w for w in argv if w != '--help']
 print(hm)
 exit()
###############################
if '-gcc' in argv:
 argv=[w for w in argv if w not in '-gcc']
 q=pp('gcc --version').read()
 q=q.split()
 if len(q) > 2:
  q=q[2]
 else:
  q=q[0]
 q=q.split('.')[0]
 q=int(q)
 if q<10:
  for w in io.keys():
   if 'L' in io[w]:
    io[w]=io[w].replace('L','ll')
###############################
uncom=1
if '-u' in argv:
 argv=[w for w in argv if w!='-u']
 uncom=0
###############################
brief=0
if '-b' in argv:
 argv=[w for w in argv if w!='-b']
 brief=1
###############################
brtg=0
if '-brtg' in argv:
 argv=[w for w in argv if w!='-brtg']
 brtg=1
###############################
node=0
if '-node' in argv:
 argv=[w for w in argv if w!='-node']
 node=1
###############################
unrun=1
if '-c' in argv:
 argv=[w for w in argv if w != '-c']
 unrun=0
###############################
restore=0
if '-r' in argv:
 argv=[w for w in argv if w!= '-restore']
 restore=1
###############################
def dif(q):
 global asym
 a=choice(asym)
 while a in q:
  a+=choice(asym)
 return a
###############################
def bs(q,e):
 q=q.split(e)
 w=0
 d=1
 while d:
  d=0
  while w<len(q):
   w+=1
   if q[w-1].count('(')>q[w-1].count(')') or q[w-1].count('[')>q[w-1].count(']') or q[w-1].count('{')>q[w-1].count('}'):
    q[w-1]+=e+q[w]
    q=q[:w]+q[w+1:]
    w=len(q)
    d=1
 return q
###############################
def itype(q,i=0,s=0):
 global smint
 smi=s+smint
 q=q.strip()
 sym=asym+'.'
 if q=='':
  return ''
 if q[0]=='(' and ')' in q and unp(q[1:].split(')')[0],1):
  return q[1:].split(')')[0]
 b=dif(q)
 for w in q:
  if w not in sym:
   q=q.replace(w,b)
 q=[w for w in q.split(b) if w][0]
 if smi:
  df={'strlen':'int','fopen':'file'}
 else:
  df={'strlen':'llint','fopen':'file'}
 if q in df:
  return df[q]
 if '.' in q and q.split('.')[1]=='size':
  return itype('0')
 if '.' in q and q.split('.')[1]=='begin':
  return itype(q.split('.')[0])
 if '.' in q and q.split('.')[1]=='end':
  return itype(q.split('.')[0])
 if '.' in q:
  q=q.split('.')
  if q[0].isdigit() and q[1].isdigit():
   return 'ldouble'
  q=[w.strip() for w in q]
  return struct[itype(q[0])][q[1]]
 if q[-2:]=='LL' and (q[:-2].isdigit() or q[0]=='-' and q[1:-2].isdigit()):
  return 'llint'
 if q[-1:]=='L' and (q[:-1].isdigit() or q[0]=='-' and q[1:-1].isdigit()):
  q=int(q[:-1])
  if smi:
   if -2**63<=q<2**63:
    return 'lint'
   else:
    return 'llint'
  return 'llint'
 if q.isdigit() or q[:1]=='-' and q[1:].isdigit():
  q=int(q)
  if smi:
   if -2**31<=q<2**31:
    return 'int'
   elif -2**63<=q<2**63:
    return 'lint'
   else:
    return 'llint'
  return 'llint'
 if q[0]==q[-1]=="'":
  return 'char'
 e=''
 global listvars
 for w in listvars:
  if q in w:
   e=w[q]
 '''
 global vars
 global defnow
 for w in defnow:
  if '*'+q in vars[w[1]].keys():
   e=vars[w[1]]['*'+q]
  if q in vars[w[1]].keys():
   e=vars[w[1]][q]
 e=e.replace('*','')
'''
 e=typesplit(e)
 if i:
  e[0]=e[0].replace('c','')
 e=e[0]+e[1]
 return e
###############################
def typesplit(q):
 q=''.join([w for w in q if w in asym])
 if q in struct:
  return ['',q]
 be=''
 en=''
 for w in maint:
  if q[-len(w):] == w:
   en=w
   be=q[:-len(w)]
   break
 if en == 'double':
  be+='l'
  en='float'
 be=''.join(sorted(be))
 return [be,en]
###############################
def unp(q,ww=0,m=0):
 global mod
 a=typesplit(q)
 be,en=a
 if en == 'file':
  en='FILE'
  mod+=['stdlib.h']
 if en == 'str':
  en='char'
  mod+=['string.h']
 if en == 'string':
  en='std::string'
  mod+=['string']
 if en=='int' and smint==0 and m!='main':
  be+=(2-be.count('l'))*'l'
  be=''.join(sorted(be))
 if en=='float' and smint==0:
  be+=(1-be.count('l'))*'l'
  en='double'
  be=''.join(sorted(be))
 if en=='float' and 'l' in be:
  en='double'
  be=be[:be.index('l')]+be[be.index('l')+1:]
  be=''.join(sorted(be))
 if ww:
  if be+en:
   return 1
  else:
   return 0
 if be+en:
  toex=''
  for w in unpac.keys():
   toex+=(unpac[w]+' ')*be.count(w)
  return toex+en
 return q
###############################
def gio(q):
 q=typesplit(q)
 q[0]=[w for w in q[0] if w in 'lLuhH']
 q[0]=sorted(q[0])
 if q[1]=='bool':
  q[1]='int'
 q[0]=''.join(q[0])
 if q[1]=='auto':
  print('\x1b[91m[error]\x1b[0m unable to print type auto')
  exit()
 return io[q[0]+q[1]]
###############################
def init(type,q=None):
 global node
 if node:
  return ['',type+' '+q]
 if q==None:
  type=q
  q=' '.join(q.split())
  q=q.split(' ',1)
  if len(q)==1:
   print('\x1b[95m[warning]\x1b[0m var '+q[0]+'is uncreated')
   return ['',q[0]]
  if len(q)==0:
   print('\x1b[95m[warning]\x1b[0m internall error')
   return ['','']
  type,q=q
 q=q.strip()
 q=' '.join(q.split())
 type=type.strip()
# type,q=q.split(' ',1)
 q=q.strip()
 name=q.split('[')[0].split('(')[0].replace('*','').strip()
 if typesplit(type)[1]=='int' and smint==0 and name!='main':
  type='llint'
 if typesplit(type)[1]=='float' and smint==0:
  type='llfloat'
 global listvars
 listvars[-1][name]=type
 return [type,name]
###############################
if not (argv):
 print('and what file should I compile? run with -h for help')
 exit(1)
###############################
if not(exists(argv[0])):
 prrint('\x1b[91m[error]\x1b[0m Could not find '+argv[0])
 exit(2)
###############################
a=open(argv[0])
q=a.read()
a.close()
ort=q
##############################
if restore:
 a=open('restore','w')
 q=q.split('\n')[0]
 q=[w for w in q if w in '0123456789abcdef']
 q=''.join(q)
 a.write(unhexlify(q.encode()).decode())
 a.close()
 exit()
##############################
q+='\npass\n'
##############################
if 'compile' in q:
 cs1,cs=q.split('compile',1)
 cs2=cs
 while cs[0] in ' \t':
  cs=cs[1:]
 if cs[0]==':':
  cs=cs[1:]
  while cs[0] in ' \t':
   cs=cs[1:]
  if cs[0]=='\n':
   cs=cs[1:]
   while cs[0] in ' \t':
    cs=cs[1:]
   gcomp,cs=cs.split('\n',1)
   q=cs1+cs
###############################
q=''.join([chr(ord(w)%msym) for w in q])
nq=''
ws=0
while q:
 if ws==0 and q[:3]=="'''":#'''
  ws=1
  nq+='"'
  q=q[3:]
 elif ws==1 and q[:3]=="'''":#'''
  ws=0
  nq+='"'
  q=q[3:]
 elif ws==0 and q[:1]=='"':
  ws=2
  nq+='"'
  q=q[1:]
 elif ws==2 and q[:1]=='"':
  ws=0
  nq+='"'
  q=q[1:]
 elif ws==0 and q[:1]=="'":
  ws=3
  nq+="'"
  q=q[1:]
 elif ws==3 and q[:1]=="'":
  ws=0
  nq+="'"
  q=q[1:]
 elif ws==0 and q[:2]=='%*':
  ws=4
  q=q[2:]
 elif ws==4 and q[:2]=='*%':
  ws=0
  q=q[2:]
 elif ws==0 and q[:2]=='/*':
  ws=5
  q=q[2:]
 elif ws==5 and q[:2]=='*/':
  ws=0
  q=q[2:]
 elif ws==0 and q[:1]=='#':
  ws=6
  q=q[1:]
 elif ws==6 and q[:1]=='\n':
  ws=0
  q=q[1:]
 elif ws==0:
  nq+=q[0]
  q=q[1:]
 elif ws==1:
  add=q[0]
  q=q[1:]
  if add=='\n':
   if brtg:
    add='<br>'
   else:
    add='\\n'
  if add=='\'':
   add='\\\''
  if add=='\"':
   add='\\\"'
  for www in add:
   nq+=chr(msym+ord(www))
 elif ws<5:
  nq+=chr(msym+ord(q[0]))
  q=q[1:]
 else:
  q=q[1:]
q=nq
###############################
q=q.replace('\t',' ')
###############################
nq=''
while len(q)>1:
 nq+=q[0]
 if set(';\n ')&set(q[:2]):
  pass
 elif q[0] in asym and q[1] in asym:
  pass
 elif q[0] in asym and q[1] in '"\'':
  pass
 elif q[:2] in ['++',':=','--','==','!=','>=','<=','&&','||','<<','>>','+=','-=','*=','/=','%=','&=','|=','^=','<=','>=','->','::','""',"''"]:
  pass
 elif ord(max(q[:2])) >= msym:
  pass
 else:
  nq+=' '
 q=q[1:]
q=nq+q
###############################
q=q.replace(';','\n')
###############################
q=q.split('\n')
###############################
q=[w for w in q if w != ' '*len(w)]
q=[[0,w,''] for w in q]
for w in q:
 while w[1][0] == ' ':
  w[1]=w[1][1:]
  w[0]+=1
 while w[1][-1] == ' ':
  w[1]=w[1][:-1]
###############################
for w in q:
 w[1]=' '.join(w[1].split())
###############################
for w in q:
 nodc=':;'+chr(msym+ord('\n'))+chr(msym+ord(';'))
 if node:
  nodc+='>'
 if w[1][-1] not in nodc:
   w[1]+=';'
###############################
deb=-1
for w in q:
 if w[1]=='debug :':
  deb=w[0]
  w[1]='global :'
 elif w[0]<=deb:
  deb=-1
 elif deb>-1:
  wd=w[1].split('=')
  debug[wd[0].strip()]=wd[1].strip()
  w[1]='int debug_'+w[1]
###############################
if node==0:
 main=[]
 inmain=1
 for w in q:
  if w[0] == 0:
   inmain=1
  if w[1][:4] == 'def ':
   inmain=0
  if w[1]== 'global :':
   inmain=2
   w[1]=''
  if inmain==1:
   main+=[w[:]]
   w[1]=''
  if inmain==2:
   w[0]-=1
 q=[w for w in q if w[1] != '']
 q+=[[0,'def int main ( ) :','']]
 for w in main:
  w[0]+=1
 q+=main
###############################
#start#
###############################
linow=-1
switch=[]
for w in q:
 listvars=listvars[:w[0]+1]
 while len(listvars)<w[0]+1:
  listvars+=[dict()]
 linow+=1
 if switch and w[0] <= switch[-1][0]:
  switch=switch[:-1]
 if w[0] <= struos:
  struop=''
 if switch and switch[-1][1] == -1 and w[1][-1]==':':
  switch[-1][1]=w[0]
  w1=w[1][:-1]
  w[1]=''
  for w2 in w1.split(','):
   w[1]+='case '+w2+':'
 elif switch and switch[-1][1]==w[0] and w[1][:7]=='default'and w[1][-1]==':':
  w[1]=('break;\n'+' '*w[0])*casebr+w[1]
  casebr=1
 elif switch and switch[-1][1]==w[0] and w[1][-1]==':':
  w1=w[1][:-1]
  w[1]=('break;\n'+' '*w[0])*casebr
  for w2 in w1.split(','):
   w[1]+='case '+w2+':'
  casebr=1
 elif w[1][:7]=='switch ' and w[1][-1]==':':
  w[1]='switch('+w[1][7:-1]+')'
  switch+=[[w[0],-1]]
 elif w[1]=='unbreak;':
  casebr=0
  w[1]=''
 elif w[1][:5]=='each ' and w[1][-1]==':':
  tmpar=w[1][5:-1].strip()
  tmpit='each_'+tmpar
  w[1]=''
  if itype('index_'+tmpit)=='':
   init('int','index_'+tmpit)
   w[1]+='int index_'+tmpit+';\n'+' '*w[0]
  if itype('tmpit')=='':
   init(itype(tmpar),tmpit)
   w[1]+=unp(itype(tmpar))+' '+tmpit+';\n'+' '*w[0]
  w[1]+='for(index_'+tmpit+'=0,'+tmpit+'='+tmpar+'[index_'+tmpit+'];index_'+tmpit+'<len_'+tmpar+';'+tmpar+'[index_'+tmpit+']='+tmpit+',index_'+tmpit+'++)'
  w[2]+=tmpit+'='+tmpar+'[index_'+tmpit+'];'
 elif w[1][:7] == 'import ':
  mod+=[w[1][7:-1]]
  w[1]=''
 elif [e for e in w[1] if e != ' '] == list('aimport;'):
  mod+=['bits/stdc++.h']
  w[1]=''
 elif w[1][:8] == 'cimport ':
  mod+=[w[1][8:-1]+'.h']
  w[1]=''
 elif w[1][:8] == 'limport ':
  fif+=[w[1][8:-1].strip()]
  if fif[-1]=='get':
   init('str','gets')
   init('int','geti')
   init('float','getf')
  w[1]=''
 elif [e for e in w[1] if e!=' '][:3] == list('sh('):
  mod+=['stdlib.h']
  w[1]='system'+w[1][2:]
 elif w[1][:4] == 'for ' and w[1][-1] == ':':
  w[1]=w[1][4:-1].strip()
  if w[1].count(':')==2:
   w[1]='for('+w[1].replace(':',';').replace(' and ',' && ').replace(' or ',' || ').replace(' not ',' ! ')+')'
  elif ' in ' in w[1]:
   tmpit=w[1].split(' in ')[0].strip()
   tmpar=w[1].split(' in ')[1].strip()
   listvars+=[dict()]
   init(itype(tmpar),tmpit)
   w[1]='for('+unp(itype(tmpar))+' '+tmpit+':'+tmpar+')'
   '''
   w[1]=''
   if itype('index_'+tmpit)=='':
    init('int','index_'+tmpit)
    w[1]+='int index_'+tmpit+';\n'+' '*w[0]
   if itype(tmpit)!=itype(tmpar):
    init(itype(tmpar),tmpit)
    w[1]+=itype(tmpar)+' '+tmpit+';\n'+' '*w[0]
   w[1]+='for(index_'+tmpit+'=0,'+tmpit+'='+tmpar+'[index_'+tmpit+'];index_'+tmpit+'<len_'+tmpar+';'+tmpar+'[index_'+tmpit+']='+tmpit+',index_'+tmpit+'++,'+tmpit+'='+tmpar+'[index_'+tmpit+'<len_'+tmpar+'-1?index_'+tmpit+':len_'+tmpar+'-1])'
   '''
  else:
   test=w[1].split(':',1)
   test=test[1].replace(' and ',' && ').replace(' or ',' || ').replace(' not ',' ! ') if len(test)>1 else ''
   w[1]=w[1].split(':')[0]
   te=0
   if '<' in w[1] or '>' in w[1]:
    while w[1][te] not in '<>':
     te+=1
    te=w[1][te]
   if te=='<':
    if '=' not in w[1]:
     w[1]='0='+w[1]
    beg=w[1].split('=')[0]
    it=w[1].split('=')[1].split('<')[0]
    end=w[1].split('<')[1]
    st='++'
   if te=='>':
    if '=' not in w[1]:
     w[1]='0='+w[1]
    beg=w[1].split('=')[0]
    it=w[1].split('=')[1].split('>')[0]
    end=w[1].split('>')[1]
    st='--'
   if test:
    w[1]='for('+it+'='+beg+';'+test+';'+it+st+')'
   else:
    w[1]='for('+it+'='+beg+';'+it+te+end+';'+it+st+')'
   '''
   ext='for('
   if '<' in w[1]:
    if '=' in w[1]:
     ext+=w[1].split('=')[1].split('<')[0]
     ext+='='
     ext+=w[1].split('<')[0].split('=')[0]
     ext+=';'
     if test:
      ext+=test
     else:
      ext+=w[1].split('=')[1]
     ext+=';'
     ext+=w[1].split('=')[1].split('<')[0]
     ext+='++)'
    else:
     ext+=w[1].split('<')[0]
     ext+='=0;'
     if test:
      ext+=test
     else:
      ext+=w[1]
     ext+=';'
     ext+=w[1].split('<')[0]
     ext+='++)'
   if '>' in w[1]:
    if '=' in w[1]:
     ext+=w[1].split('=')[1].split('>')[0]
     ext+='='
     ext+=w[1].split('>')[0].split('=')[0]
     ext+=';'
     if test:
      ext+=test
     else:
      ext+=w[1].split('=')[1]
     ext+=';'
     ext+=w[1].split('=')[1].split('>')[0]
     ext+='--)'
    else:
     ext+=w[1].split('>')[0]
     ext+='=0;'
     if test:
      ext+=test
     else:
      ext+=w[1]
     ext+=';'
     ext+=w[1].split('>')[0]
     ext+='--)'
    '''

   if itype(it)!=itype(end,1) and itype(end,1):
    init(itype(end,1),it)
    w[1]=unp(itype(end,1))+' '+it+';\n'+' '*w[0]+w[1]
   #w[1]=ext
 elif w[1][:6] == 'while ' and w[1][-1] == ':':
  w[1]='while('+w[1][6:-1].replace(' and ',' && ').replace(' or ',' || ').replace(' not ',' ! ')+')'
 elif w[1][:6] == 'while ' and w[1][-1] == ';':
  w[1]='while('+w[1][6:-1].replace(' and ',' && ').replace(' or ',' || ').replace(' not ',' ! ')+');'
 elif w[1][:4] == 'for ' and w[1][-1] != ':':
  w[1]='for('+w[1][4:-1].replace(' and ',' && ').replace(' or ',' || ').replace(' not ',' ! ')+')'
 elif w[1] == 'pass;':
  w[1]=''
 elif w[1][:5] == 'elif ' and w[1][-1] == ':':
  w[1]='else if('+w[1][5:-1].replace(' and ',' && ').replace(' or ',' || ').replace(' not ',' ! ')+')'
 elif [e for e in w[1] if e!=' '] == list('else:'):
  w[1]='else'
 elif [e for e in w[1] if e!=' '] == list('do:'):
  w[1]='do'
 elif w[1][:7] == 'resize ':
  mod+=['stdlib.h']
  w[1]=w[1][7:-1]
  vat=w[1]
  tmpvar='['.join(vat.split('[')[:-1])
  tmptype=itype(tmpvar)
  tmpcount=vat.split('[')[-1].split(']')[0]
  tmpouttype=unp(tmptype)
  w[1]=tmpvar+'=('+tmpouttype+'*)realloc('+tmpvar+',sizeof('+tmpouttype+')*('+tmpcount+'));len_'+tmpvar.strip()+'='+tmpcount+';'
 elif w[1][:4] == 'mal ':
  mod+=['stdlib.h']
  w[1]=w[1][4:-1]
  vat=w[1]
  tmpvar='['.join(vat.split('[')[:-1])
  tmptype=itype(tmpvar)
  tmpcount=vat.split('[')[-1].split(']')[0]
  tmpouttype=unp(tmptype)
  w[1]='len_'+tmpvar.strip()+'='+tmpcount+';'+tmpvar+'=('+tmpouttype+'*)malloc(sizeof('+tmpouttype+')*(len_'+tmpvar.strip()+'));'
 elif w[1][:4] == 'cal ':
  mod+=['stdlib.h']
  w[1]=w[1][4:-1]
  vat=w[1]
  tmpvar='['.join(vat.split('[')[:-1])
  tmptype=itype(tmpvar)
  tmpcount=vat.split('[')[-1].split(']')[0]
  tmpouttype=unp(tmptype)
  w[1]='len_'+tmpvar.strip()+'='+tmpcount+';'+tmpvar+'=('+tmpouttype+'*)calloc((len_'+tmpvar.strip()+'),sizeof('+tmpouttype+'));'
 elif w[1][:4] == 'add ':
  mod+=['stdlib.h']
  w[1]=w[1][4:-1]
  vat=w[1]
  tmpvar='['.join(vat.split('[')[:-1])
  tmptype=itype(tmpvar)
  tmpcount=vat.split('[')[-1].split(']')[0]
  tmpouttype=unp(tmptype)
  w[1]=tmpvar+'=('+tmpouttype+'*)realloc('+tmpvar+',sizeof('+tmpouttype+')*(len_'+tmpvar.strip()+'+1));len_'+tmpvar.strip()+'++;'+tmpvar+'[len_'+tmpvar.strip()+'-1]='+tmpcount+';'
 elif w[1][:5] == 'cnew ':
  mod+=['stdlib.h']
  w[1]=w[1][:-1]
  tmptype=w[1].split()[1]
  tmpouttype=unp(tmptype)
  vat=' '.join(w[1].split()[2:])
  tmpvar=vat.split('[')[0]
  tmpcount=vat.split('[')[1].split(']')[0]
  init(tmptype,tmpvar)
  init('int','len_'+tmpvar.strip())
  w[1]='int','len_'+tmpvar.strip()+'='+tmpcount+';'+tmpouttype +'*'+tmpvar+'=('+tmpouttype+'*)calloc((len_'+tmpvar.strip()+'),sizeof('+tmpouttype+'));'
 elif [e for e in w[1]][:5] == list('sort('):
  mod+='algorithm functional array iostream iterator'.split()
  uns+=['std']
 elif w[1][:4]=='new ':
  w[1]=w[1][4:].strip()
  tmptype=w[1].split(' ')[0]
  w[1]=' '.join(w[1].split(' ')[1:])
  init(tmptype,w[1])
  w[1]='vector <'+tmptype+'> '+w[1]
  mod+=['vector']
  uns+=['std']
 elif w[1][:6] =='class ' and w[1][-1]==':':
  struct+=w[1][6:-1].strip()
  w[1]=w[1][:-1]
 elif w[1][:5]=='push ':
  w[1]=w[1][5:-2]
  te=1
  op=1
  while op:
   if w[1][-te]=='[':
    op-=1
   if w[1][-te]==']':
    op+=1
   te+=1
  tmpedd=w[1][:-te+1]
  tmpadd=w[1][-te+2:]
  w[1]=tmpedd+'.push_back('+tmpadd+');'
 elif w[1][:5]=='name ':
  uns+=[w[1][5:].strip()]
  w[1]=''
 elif w[1][:5] == 'mnew ':
  mod+=['stdlib.h']
  w[1]=w[1][:-1]
  tmptype=w[1].split()[1]
  tmpouttype=unp(tmptype)
  vat=' '.join(w[1].split()[2:])
  tmpvar=vat.split('[')[0]
  tmpcount=vat.split('[')[1].split(']')[0]
  init(tmptype,tmpvar)
  init('int','len_'+tmpvar.strip())
  w[1]='int len_'+tmpvar.strip()+'='+tmpcount+';'+tmpouttype +'*'+tmpvar+'=('+tmpouttype+'*)malloc(sizeof('+tmpouttype+')*(len_'+tmpvar.strip()+'));'
 elif w[1][:3] == 'if ' and w[1][-1] == ':':
  w[1]='if('+w[1][3:-1].replace(' and ',' && ').replace(' or ',' || ').replace(' not ',' ! ')+')'
 elif w[1][:6]=='scan (' or '. read (' in w[1] and itype(w[1]) in ['string','str','file']:
  sss=0
  if '. read (' in w[1] and itype(w[1]) in ['string','str','file']:
   sss=1
   strin=w[1].split(' . read (')[0]
   if itype(w[1])=='file':
    mod+=['stdlib.h']
   else:
    mod+=['string.h']
  mod+=['stdio.h']
  tmp1=''
  tmp2=''
  tmp3=''
  tmp4=''
  w[1]=w[1].split('(',2)[1]
  w[1]=')'.join(w[1].split(')')[:-1])
  for e in bs(w[1],','):
   if len(e.split())>1 and unp(e.split()[0],1):
    tmp3+=unp(e.split()[0])+' '+' '.join(e.split()[1:])+';\n'+' '*w[0]
    tmp1+='%'+gio(init(e)[0])
    cadd=1
    if e.split()[0] in ['string','str']:
     cadd=1-cadd
    tmp2+=','+'&('*cadd+e.strip().split(' ',1)[1]+('.begin()' if e.split()[0]=='string' else '')+')'*cadd
    if e.split()[0] == 'string':
     tmp4+=' '.join(e.split()[1:])+'='+' '.join(e.split()[1:])+'.c_str();'
    continue
   e=e.strip()
   if e[0] == '`':
    add=0
    e=e[1:]
   else:
    add=1
   if e[0]==e[-1] and e[0] in '\"\'':
    tmp1+=e[1:-1]
   elif '`' in e:
    tmp1+='%'+e.split('`')[1].strip()
    tmp2+=','+'&('*add+e.split('`')[0].strip()+')'*add
   else:
    tmptype=e.split('[')[0].strip().replace('*','').strip()
    deffo=itype(tmptype)
    if deffo:
     tmp1+='%'+gio(deffo)
     cadd=add
     if deffo=='string':
      tmp4+=e+'='+e+'.c_str();'
     if deffo in ['string','str']:
      cadd=1-cadd
     tmp2+=','+'&('*cadd+e.strip()+('.begin()' if deffo=='string' else '')+')'*cadd
    else:
     prrint('\x1b[91m[error line '+str(linow)+']\x1b[0m could not scan '+tmptype+' at '+w[1])
     exit(5)
  if sss:
   if itype(strin)=='file':
    w[1]=tmp3+'fscanf('+file+',"'+tmp1+'"'+tmp2+');'+tmp4
   else:
    w[1]=tmp3+'sscanf('+strin+('.begin()' if itype(strin)=='string' else '')+',"'+tmp1+'"'+tmp2+');'+tmp4
  else:
   w[1]=tmp3+'scanf("'+tmp1+'"'+tmp2+');'+tmp4
 elif w[1][:7]=='print ('or '=' in w[1] and '[' not in w[1].split('=')[0] and itype(w[1]) in ['str','string']:
  sss=0
  if itype(w[1]) in ['str','string']:
   sss=1
   strin=w[1].split('=')[0]
   if strin[-1]=='+':
    sss=2
  mod+=['stdio.h']
  tmp1=[]
  tmp2=''
  tmp4=''
  if sss==0:
   sep=' '
   end='\\n'
   w[1]='('.join(w[1].split('(')[1:])
   w[1]=')'.join(w[1].split(')')[:-1])
   file=bs(w[1],',')[0]
   if '.' not in file and itype(file)=='file':
    w[1]=','.join(bs(w[1],',')[1:])
   else:
    file=''
  else:
   sep=''
   end=''
   if strin[-1]=='+':
    strin=strin[:-1]
   w[1]=w[1].split('=',1)[1]
   if sss==2:
    w[1]=strin+'+'+w[1]
   w[1]=w[1][:-1]
  for e in bs(w[1],'+' if sss else ','):
   e=e.strip()
   if e=='':
    pass
   elif len(e.split('='))==3 and e.split('=')[0].strip()=='format':
    format,sep,end=e.split('=')
    sep=sep.strip()[1:-1]
    end=end.strip()[1:-1]
   elif e[0] == '"' and e[-1] == '"':
    tmp1+=[e[1:-1]]
   elif e[0] == "'" and e[-1] == "'":
    tmp1+=[e[1:-1]]
   elif '`' in e:
    tmp1+=['%'+e.split('`')[1].strip()]
    tmp2+=','+e.split('`')[0].strip()
   else:
    tmptype=e.split('[')[0].strip().replace('*','')
    deffo=itype(tmptype,s=1)
    if deffo:
     tmp1+=['%'+gio(deffo)]
     tmp2+=','+e.strip()+('.begin()' if deffo=='string' else '')
    else:
     prrint('\x1b[91m[error line '+str(linow)+']\x1b[0m could not print '+tmptype+' at '+w[1])
     exit(6)
  if sss and itype(strin)=='string':
   tmp4+=strin+'='+strin+'.c_str();'
  if sss:
   w[1]='sprintf('+strin+('.begin()' if itype(strin)=='string' else '')+',"'+sep.join(tmp1)+end+'"'+tmp2+');'+tmp4
  elif file:
   w[1]='fprintf('+file+',"'+sep.join(tmp1)+end+'"'+tmp2+');'+tmp4
  else:
   w[1]='printf("'+sep.join(tmp1)+end+'"'+tmp2+');'+tmp4
  if 'printlimit' in debug:
   w[1]+='debug_printlimit--;if (debug_printlimit < 0) {printf("\033[31m[debug_printlimit]\033[0m\\n");return 0;}'
 elif w[1][:4] == 'def ' and w[1][-1] == ':':
  w[1]=w[1][4:-1]
  if len(w[1].split('(')[0].split())<2:
   if node:
    w[1]='function '+w[1]
   else:
    w[1]='auto '+w[1]
  nw=init(w[1].split('(')[0])
  listvars+=[dict()]
  nw=unp(nw[0],m=nw[1])+' '+nw[1]+'('
  nwl=[]
  for e in w[1].split('(')[1].split(')')[0].split(','):
   if e != ' '*len(e):
    if ' ' not in e.strip():
     if node==0:
      e='auto '+e
    tmp=init(e)
    nwl+=[unp(tmp[0])+' '+tmp[1]]
  w[1]=nw+','.join(nwl)+')'
 elif w[1][:7] == 'struct ' and w[1][-1]==':':
  struop=w[1][7:-1].strip()
  struct[struop]=dict()
  w[1]='typedef '+w[1][:-1]
  struos=w[0]
 elif unp(w[1].split(' ')[0],1):
  tmp=' '.join(w[1][:-1].split(' ')[1:])
  tmptype=w[1].split(' ')[0]
  nw=unp(tmptype)+' '
  for e in tmp.split(','):
   ee=e.split('=')[0]
   if struop:
    struct[struop][ee]=tmptype
   else:
    init(tmptype,ee)
   nw+=e+','
  if tmptype in struct:
   nw=nw
  w[1]=nw[:-1]+';'
 elif node == 0 and '=' in w[1] and set(w[1].split('=')[0].strip()) | set(asym) == set(asym) and itype(w[1].split('=')[0])=='':
  tmpty=itype(w[1][:-1].split('=')[1])
  if not tmpty:
   #print('\x1b[95m[warning]\x1b[0m unabe to create variable '+w[1].split('=')+' at '+w[1])
   pass
  else:
   init(tmpty,w[1].split('=')[0])
   w[1]=unp(tmpty)+' '+w[1]
 elif ':=' in w[1]:
  w[1]=w[1].replace(':=','=')
 if w[1]:
  bou=dif(w[1])
  w[1]=w[1].replace(')',bou+')').replace('(','('+bou).split(bou)
  w[1]=[unp(e) if e and e[0] not in '()' and e[-1] not in '()' and unp(e,1) else e for e in w[1]]
  w[1]=''.join(w[1])
###############################
q+=[[0,'','']]
struop=-1
for w in range(len(q)-1):
 if (q[w][1][:15]=='typedef struct ' or q[w][1][:6]== 'class ' )and q[w][1][-1]!=';':
  struop=q[w][0]
 if q[w][0] == q[w+1][0]:
  q[w]=' '*unhack*q[w][0]+q[w][1]+('\n'+' '*unhack*q[w][0])*int(bool(len(q[w][2])))+q[w][2]
 elif q[w][0] > q[w+1][0]:
  q[w]=' '*unhack*q[w][0]+q[w][1]+'}'*(q[w][0]-q[w+1][0])+('\n'+' '*unhack*q[w][0])*int(bool(len(q[w][2])))+q[w][2]
 elif q[w][0] < q[w+1][0]:
  q[w]=' '*unhack*q[w][0]+q[w][1]+'{'*(q[w+1][0]-q[w][0])+('\n'+' '*unhack*q[w][0])*int(bool(len(q[w][2])))+q[w][2]
 if q[w+1][0]<=struop:
  q[w]+=';'
  struop=-1
q[-1]=''
###############################
q=('\n').join(q)
###############################
q=q.split('\n')
###############################
if node==0:
 w=0
 while 'int main()' not in q[w]:
  w+=1
 q1=[]
 q4=q[:w]
 q2=q[w:]
 q3=[]
 for w in q2:
  if 'one_string_global ' in w:
   w=w.replace('one_string_global ','')
   q1+=[w]
  else:
   q3+=[w]
 q=q1+q4+q3
###############################
q=('\n'*unhack).join(q)
###############################
mod=list(set(mod))
mods=''
mmods=''
uns=list(set(uns))
for w in uns:
 mods+='using namespace '+w+';\n'
fif=list(set(fif))
for w in fif:
 if w=='get':
  mods+='''
char *gets(){char a[101010];scanf("%s",a);auto s=(char*)malloc(strlen(a)+1);strcpy(s,a);return s;}
char *gets(FILE *d){char a[101010];fscanf(d,"%s",a);auto s=(char*)malloc(strlen(a)+1);strcpy(s,a);return s;}
char *gets(char *d){char a[101010];sscanf(d,"%s",a);auto s=(char*)malloc(strlen(a)+1);strcpy(s,a);return s;}
long long int geti(){long long int q;scanf("%Li",&q);return q;}
long long int geti(FILE *a){long long int q;fscanf(a,"%Li",&q);return q;}
long long int geti(char *a){long long int q;sscanf(a,"%Li",&q);return q;}
long double getf(){long double q;scanf("%Lf",&q);return q;}
long double getf(FILE *a){long double q;fscanf(a,"%Lf",&q);return q;}
long double getf(char *a){long double q;sscanf(a,"%Lf",&q);return q;}
'''
  mod+=['stdio.h','string.h','stdlib.h']
 if w=='rand':
  mmods+='\nsrand(time(NULL));'
  mod+=['stdlib.h','time.h']
rmods=''
mod=list(set(mod))
for w in mod:
 rmods+='#include <'+w+'>\n'
q=rmods+mods+q
q=q.replace('int main(){','int main(){'+mmods)
###############################
q=''.join([chr(ord(w)%msym) for w in q])
###############################
ort=hexlify(ort.encode()).decode()
if node:
 a=open('index.html','w')
 a.write(('<!--'+ort+'-->\n')*uncom+q)
else:
 a=open('outcode.cpp','w')
 a.write(('////'+ort+'\n')*uncom+q)
a.close()
###############################
if unrun:
 if brief:
  qq=sh('(g++ outcode.cpp 2>&1) > out__tmp____')
  qqq=open('out__tmp____').read()
  sh('rm out__tmp____')
  if qq:
   print(qqq[:256])
   exit()
 else:
  if sh(gcomp.format('outcode.cpp')):
   exit()
 try:
  q=sh('./a.out')
 except KeyboardInterrupt:
  if exitcode==0:
   print()
 else:
  if exitcode:
   prrint('\x1b[93m[exit code: '+str(q)+']\x1b[0m')
  exit(q)
